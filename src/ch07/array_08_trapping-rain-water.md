## 08 ) 빗물 트래핑

---
### 문제 : 리트코드 42.Trapping Rain Water
높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라.

```
입력 예시
height = [0,1,0,2,1,0,1,3,2,1,2,1]

출력 예시
6
```

### 풀이과정
### 1) 투 포인터
+ 

### 2) 스택
#### 아이디어
0. 문제를 풀기 위해 스택이 필요할 것 같다. 스택에 어떤 값을 저장해야 하는가?   
    ⇒ 배열에서 현재 뽑은 값의 인덱스(height라는 input배열 중 <b>현재 값의 인덱스</b>) ★   
   ⇒ why? 쌓인 물의 양을 구하려면 "거리"와 높이를 구해야하는데, 이 중 거리를 구하는데 필요하니까
1. 쌓인 물의 양을 구하려면, 이전 물높이와 현재 물높이가 달라서 격차가 생기는 지점을 파악해야함. ⇒ 꺾이는 부분 [변곡점]   
   ⇒ 포인트 : 스택을 읽다가 현재 뽑은 값(curr)와 스택에 가장 위에 있는 값(top)을 비교하여 curr가 top보다 클 때! 물이 쌓임. 당연함.     
2. 변곡점이 생긴 지점에서 물의 양을 계산하는 방법   
   ⇒ 1번. 실제로 쌓인 물 높이는 얼마인가?   
   ⇒ 2번. 물이 쌓여있는 거리는 어떻게 구해야 하는가?   
   ⇒ 높이 * 거리를 구하면 물의 양이 나옴!
3. 쌓인 물 높이 구하기   
   ⇒ 당연히 현재 높이(curr) > 이전 높이(height[stack.peek()])인 상황 cf) <b>stack.peek()</b> : pop()처럼 추출하는 것이 아니라, 다음번에 추출될 엘리먼트가 무엇인지 조회만 하는 연산   
   ⇒ 단순히 "현재 높이 - 이전 높이" 할 수 없음   
   ⇒ ex1. 1(peek), 0(top), 1(curr)인 상황 : 1만큼 물이 쌓여있음, curr - top해도 가능   
   ⇒ ex2. 1(peek), 0(top), 2(curr) 인 상황에서는 높이가 1만큼 물이 쌓여있음 → curr와 peek의 값을 비교하여 더 작은 값을 구한 후! top을 빼기   
   ⇒ ex3. 0(peek), 0(top), 2(curr) 인 상황은????
4. 물이 쌓인 거리 구하기   
   ⇒ 스택의 마지막 위치까지를 거리로 계산   
   ⇒ 변곡점을 만났으면, 그 전까지 스택에 쌓아놨던 과거의 인덱스들을 while문으로 하나씩 뒤감아 보면서 각 인덱스 별로 높이가 얼마인지 계산!   
   ⇒ ex) [3,1,1,1,4] : 4를 만났을 때 스택에는 [0,1,2,3] 쌓여있음.   
   ⇒ 3번 인덱스의 높이:1, 이전 높이를 보면 이전의 높이도 1이므로 물 안 쌓임. 가다가 마지막 높이가 3인 0번 인덱스를 만나면 그때 4-0-1[거리], min(4, 3) - 바로 앞에 기둥의 높이(1)[높이]
*  java code
    ```java
    public int trap(int[] height) {
        Deque<Integer> stack = new ArrayDeque<>();
        int volume = 0;

        for (int i = 0; i < height.length; i++) {
            // 변곡점을 만나는 경우
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                // 스택에서 꺼낸다.
                Integer top = stack.pop();

                if (stack.isEmpty())
                    break;

                // 스택의 마지막 위치까지를 거리로 계산
                int distance = i - stack.peek() - 1;
                // 현재 높이 또는 스택의 마지막 위치 높이 중 낮은 값에 방금 꺼낸 높이의 차이를 물 높이로 지정
                int waters = Math.min(height[i], height[stack.peek()]) - height[top];

                // 물이 쌓이는 양은 거리와 물 높이의 곱
                volume += distance * waters;
            }

            // 진행하면서 현재 위치를 스택에 삽입
            stack.push(i);
        }
        return volume;
    }
    ```
      * 정답풀이를 봐도 이해가 안갔던 문제... 하나씩 따라 그려가면서 겨우 이해함! 여러번 보면서 더 정확히 이해하고 싶다